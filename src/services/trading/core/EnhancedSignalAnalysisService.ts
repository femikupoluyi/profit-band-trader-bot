
import { TradingConfigData } from '@/components/trading/config/useTradingConfig';
import { BybitService } from '../../bybitService';
import { TradingLogger } from './TradingLogger';
import { ServiceContainer } from './ServiceContainer';
import { SystemHealthChecker } from './SystemHealthChecker';
import { ValidationChain } from './ValidationChain';

export class EnhancedSignalAnalysisService {
  private userId: string;
  private bybitService: BybitService;
  private logger: TradingLogger;
  private healthChecker: SystemHealthChecker;

  constructor(userId: string, bybitService: BybitService) {
    this.userId = userId;
    this.bybitService = bybitService;
    this.logger = ServiceContainer.getLogger(userId);
    this.healthChecker = new SystemHealthChecker(userId, bybitService);
  }

  async analyzeAndCreateSignals(config: TradingConfigData): Promise<void> {
    try {
      console.log('\nüß† ===== ENHANCED SIGNAL ANALYSIS & CREATION =====');
      
      await this.logger.logSystemInfo('Starting signal analysis and creation', {
        tradingLogic: config.trading_logic_type,
        activePairs: config.trading_pairs.length,
        maxOrderAmount: config.max_order_amount_usd
      });

      // Validate configuration first
      const configValidation = ValidationChain.validateConfiguration(config);
      if (!configValidation.isValid) {
        console.error('‚ùå Configuration validation failed:', configValidation.errors);
        await this.logger.logError('Configuration validation failed', new Error(configValidation.errors.join(', ')));
        return;
      }

      if (configValidation.warnings.length > 0) {
        console.warn('‚ö†Ô∏è Configuration warnings:', configValidation.warnings);
      }

      // Perform health check
      const healthReport = await this.healthChecker.performHealthCheck(config);
      console.log(`üè• System health: ${healthReport.overall}`);

      if (healthReport.overall === 'critical') {
        console.error('‚ùå System health is critical - aborting signal analysis');
        await this.logger.logError('Signal analysis aborted due to critical system health', new Error('Critical system health'));
        return;
      }

      // Process each trading pair
      for (const symbol of config.trading_pairs) {
        try {
          console.log(`\nüìä Analyzing ${symbol}...`);
          
          // Create test signal for now (this would be replaced with actual analysis logic)
          const success = await this.createTestSignal(symbol, config);
          
          if (success) {
            console.log(`‚úÖ Signal created for ${symbol}`);
          } else {
            console.log(`‚ö†Ô∏è No signal created for ${symbol}`);
          }
          
        } catch (error) {
          console.error(`‚ùå Error analyzing ${symbol}:`, error);
          await this.logger.logError(`Signal analysis failed for ${symbol}`, error);
        }
      }

      console.log('‚úÖ Signal analysis and creation complete');
      
    } catch (error) {
      console.error('‚ùå Critical error in signal analysis:', error);
      await this.logger.logError('Critical error in signal analysis', error);
      throw error;
    }
  }

  async createTestSignal(symbol: string, config: TradingConfigData): Promise<boolean> {
    try {
      console.log(`üß™ Creating test signal for ${symbol}`);
      
      // Get current market price (simplified for testing)
      const mockPrice = symbol === 'BTCUSDT' ? 45000 : symbol === 'ETHUSDT' ? 3000 : 100;
      
      // Create test signal
      const dbHelper = ServiceContainer.getDatabaseHelper(this.userId);
      const signal = await dbHelper.createSignal({
        user_id: this.userId,
        symbol: symbol,
        signal_type: 'buy',
        price: mockPrice,
        confidence: 0.8,
        reasoning: `Test signal for ${symbol} - generated by enhanced analysis service`
      });

      console.log(`‚úÖ Test signal created: ${signal.id}`);
      
      await this.logger.logSuccess(`Test signal created for ${symbol}`, {
        signalId: signal.id,
        symbol,
        price: mockPrice
      });

      return true;
      
    } catch (error) {
      console.error(`‚ùå Error creating test signal for ${symbol}:`, error);
      await this.logger.logError(`Test signal creation failed for ${symbol}`, error);
      return false;
    }
  }

  async analyzeSignalWithHealthCheck(signal: any, config: TradingConfigData): Promise<{
    isValid: boolean;
    healthStatus: 'healthy' | 'warning' | 'critical';
    analysis: any;
    recommendations: string[];
  }> {
    try {
      console.log(`üîç ===== ENHANCED SIGNAL ANALYSIS START FOR ${signal.symbol} =====`);
      
      await this.logger.logSystemInfo('Starting enhanced signal analysis', {
        signalId: signal.id,
        symbol: signal.symbol,
        signalType: signal.signal_type
      });

      // Step 1: Perform system health check
      console.log('üè• Step 1: Performing system health check...');
      const healthReport = await this.healthChecker.performHealthCheck(config);
      
      console.log(`üè• System health status: ${healthReport.overall}`);
      
      if (healthReport.overall === 'critical') {
        console.warn('‚ö†Ô∏è System health is critical - signal analysis may be unreliable');
        await this.logger.logSystemInfo('Signal analysis performed with critical system health', {
          healthReport: healthReport.overall,
          criticalChecks: Object.entries(healthReport.checks)
            .filter(([_, check]) => (check as any).status === 'fail')
            .map(([name, _]) => name)
        });
      }

      // Step 2: Validate signal with comprehensive checks
      console.log('‚úÖ Step 2: Validating signal with comprehensive checks...');
      const validation = ValidationChain.validateSignal(signal, config);
      
      if (!validation.isValid) {
        console.log(`‚ùå Signal validation failed: ${validation.errors.join(', ')}`);
        return {
          isValid: false,
          healthStatus: healthReport.overall,
          analysis: { validationErrors: validation.errors },
          recommendations: this.generateRecommendations(healthReport, validation.errors)
        };
      }

      // Step 3: Perform enhanced analysis
      console.log('üß† Step 3: Performing enhanced signal analysis...');
      const analysis = await this.performEnhancedAnalysis(signal, config, healthReport);
      
      console.log(`‚úÖ Enhanced analysis complete for ${signal.symbol}`);
      
      await this.logger.logSuccess(`Enhanced signal analysis completed for ${signal.symbol}`, {
        signalId: signal.id,
        healthStatus: healthReport.overall,
        analysisResults: analysis
      });

      return {
        isValid: true,
        healthStatus: healthReport.overall,
        analysis,
        recommendations: this.generateRecommendations(healthReport, [])
      };

    } catch (error) {
      console.error(`‚ùå Error in enhanced signal analysis for ${signal.symbol}:`, error);
      await this.logger.logError(`Enhanced signal analysis failed for ${signal.symbol}`, error, {
        signalId: signal.id
      });
      
      return {
        isValid: false,
        healthStatus: 'critical',
        analysis: { error: error.message },
        recommendations: ['Fix system errors before proceeding with signal analysis']
      };
    }
  }

  private async performEnhancedAnalysis(signal: any, config: TradingConfigData, healthReport: any): Promise<any> {
    const analysis = {
      signal: {
        id: signal.id,
        symbol: signal.symbol,
        type: signal.signal_type,
        price: parseFloat(signal.price),
        confidence: signal.confidence,
        timestamp: signal.created_at
      },
      systemHealth: {
        overall: healthReport.overall,
        criticalIssues: Object.entries(healthReport.checks)
          .filter(([_, check]) => (check as any).status === 'fail')
          .length
      },
      riskAssessment: {
        maxOrderAmount: config.max_order_amount_usd,
        portfolioExposure: config.max_portfolio_exposure_percent,
        riskLevel: this.calculateRiskLevel(config, healthReport)
      },
      tradingContext: {
        activePairs: config.trading_pairs.length,
        maxPositionsPerPair: config.max_positions_per_pair,
        systemActive: config.is_active
      }
    };

    return analysis;
  }

  private calculateRiskLevel(config: TradingConfigData, healthReport: any): 'low' | 'medium' | 'high' {
    let riskScore = 0;
    
    // Health-based risk
    if (healthReport.overall === 'critical') riskScore += 3;
    else if (healthReport.overall === 'warning') riskScore += 1;
    
    // Configuration-based risk
    if (config.max_order_amount_usd > 500) riskScore += 2;
    if (config.max_portfolio_exposure_percent > 30) riskScore += 2;
    if (config.max_positions_per_pair > 2) riskScore += 1;
    
    if (riskScore >= 5) return 'high';
    if (riskScore >= 2) return 'medium';
    return 'low';
  }

  private generateRecommendations(healthReport: any, validationErrors: string[]): string[] {
    const recommendations: string[] = [];
    
    if (healthReport.overall === 'critical') {
      recommendations.push('Address critical system health issues before trading');
    }
    
    if (validationErrors.length > 0) {
      recommendations.push('Fix validation errors: ' + validationErrors.join(', '));
    }
    
    // Add health-specific recommendations
    Object.entries(healthReport.checks).forEach(([checkName, check]: [string, any]) => {
      if (check.status === 'fail') {
        recommendations.push(`Fix ${checkName}: ${check.message}`);
      }
    });
    
    if (recommendations.length === 0) {
      recommendations.push('System appears healthy - proceed with normal trading operations');
    }
    
    return recommendations;
  }
}
